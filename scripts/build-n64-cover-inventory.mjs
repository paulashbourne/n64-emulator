import { writeFile } from 'node:fs/promises';

const SOURCE_URL = 'https://api.github.com/repos/libretro-thumbnails/Nintendo_-_Nintendo_64/git/trees/master?recursive=1';
const OUTPUT_PATH = new URL('../src/roms/n64CoverInventory.ts', import.meta.url);
const BOXART_PREFIX = 'Named_Boxarts/';
const CDN_PREFIX = 'https://cdn.jsdelivr.net/gh/libretro-thumbnails/Nintendo_-_Nintendo_64@master/Named_Boxarts/';

function normalize(value) {
  return value
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .replace(/[â€™'`]/g, '')
    .replace(/[^a-z0-9]+/g, ' ')
    .trim()
    .replace(/\s+/g, ' ');
}

function canonicalFromFilename(filename) {
  return filename
    .replace(/\.png$/i, '')
    .replace(/\s*\([^)]*\)/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

function variantScore(filename) {
  const lower = filename.toLowerCase();
  let score = 0;

  if (/\((usa|north america)\)/.test(lower)) {
    score += 42;
  }
  if (/\((japan, usa|usa, japan|world)\)/.test(lower)) {
    score += 32;
  }
  if (/\((europe|pal)\)/.test(lower)) {
    score += 24;
  }
  if (/\((en|en,)/.test(lower)) {
    score += 8;
  }
  if (/\((rev|v\d)/.test(lower)) {
    score += 2;
  }

  if (/beta|proto|sample|demo|test|kiosk|competition|lodgenet|aftermarket|hack|translation|pirate|unl|homebrew/i.test(filename)) {
    score -= 80;
  }

  return score;
}

async function fetchCoverFiles() {
  const response = await fetch(SOURCE_URL, {
    headers: {
      'User-Agent': 'n64-emulator-cover-builder',
      Accept: 'application/vnd.github+json',
    },
  });

  if (!response.ok) {
    throw new Error(`GitHub tree fetch failed: ${response.status}`);
  }

  const payload = await response.json();
  if (!payload?.tree || !Array.isArray(payload.tree)) {
    throw new Error('Unexpected GitHub tree payload.');
  }

  return payload.tree
    // Skip git symlink blobs (mode 120000). jsDelivr returns the target path text for those
    // entries instead of image bytes, which causes cover render fallback in the app.
    .filter(
      (entry) =>
        entry &&
        entry.type === 'blob' &&
        entry.mode !== '120000' &&
        typeof entry.path === 'string',
    )
    .map((entry) => entry.path)
    .filter((path) => path.startsWith(BOXART_PREFIX) && path.endsWith('.png'))
    .map((path) => path.slice(BOXART_PREFIX.length));
}

function buildInventory(files) {
  const bestByNormalizedTitle = new Map();

  for (const file of files) {
    const title = canonicalFromFilename(file);
    const normalizedTitle = normalize(title);
    if (!normalizedTitle) {
      continue;
    }

    const candidate = {
      title,
      file,
      score: variantScore(file),
    };

    const existing = bestByNormalizedTitle.get(normalizedTitle);
    if (!existing) {
      bestByNormalizedTitle.set(normalizedTitle, candidate);
      continue;
    }

    if (candidate.score > existing.score) {
      bestByNormalizedTitle.set(normalizedTitle, candidate);
      continue;
    }

    if (candidate.score === existing.score && candidate.file.length < existing.file.length) {
      bestByNormalizedTitle.set(normalizedTitle, candidate);
    }
  }

  return Array.from(bestByNormalizedTitle.values())
    .sort((left, right) => left.title.localeCompare(right.title, undefined, { sensitivity: 'base' }))
    .map((entry) => ({
      title: entry.title,
      file: entry.file,
      url: `${CDN_PREFIX}${encodeURIComponent(entry.file)}`,
    }));
}

function asTsModule(entries) {
  const lines = [];
  lines.push('// Generated by scripts/build-n64-cover-inventory.mjs');
  lines.push('// Source: libretro-thumbnails/Nintendo_-_Nintendo_64 Named_Boxarts');
  lines.push('');
  lines.push('export interface N64CoverInventoryEntry {');
  lines.push('  title: string;');
  lines.push('  file: string;');
  lines.push('  url: string;');
  lines.push('}');
  lines.push('');
  lines.push('export const N64_COVER_INVENTORY: N64CoverInventoryEntry[] = [');

  for (const entry of entries) {
    lines.push(
      `  { title: ${JSON.stringify(entry.title)}, file: ${JSON.stringify(entry.file)}, url: ${JSON.stringify(entry.url)} },`,
    );
  }

  lines.push('];');
  lines.push('');

  return `${lines.join('\n')}\n`;
}

async function main() {
  const files = await fetchCoverFiles();
  const inventory = buildInventory(files);
  const moduleSource = asTsModule(inventory);
  await writeFile(OUTPUT_PATH, moduleSource, 'utf8');
  process.stdout.write(`Wrote ${inventory.length} cover entries to ${OUTPUT_PATH.pathname}\n`);
}

await main();
